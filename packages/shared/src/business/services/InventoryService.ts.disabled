import { SupabaseClient } from '@supabase/supabase-js';
import { Database } from '../../database.types';
import { 
  ResourceNotFoundError, 
  ValidationError, 
  BusinessRuleError,
  DatabaseError 
} from '../errors';

type InventoryMovement = Database['public']['Tables']['inventory_movements']['Row'];
type ProductVariant = Database['public']['Tables']['product_variants']['Row'];

interface StockAdjustmentRequest {
  variant_id: string;
  quantity_change: number;
  reason: string;
  notes?: string;
}

interface BulkStockUpdate {
  variant_id: string;
  new_quantity: number;
  reason: string;
}

interface RestockRequest {
  variant_id: string;
  quantity: number;
  supplier?: string;
  cost_per_unit?: number;
  notes?: string;
}

interface InventoryAlert {
  id: string;
  variant_id: string;
  product_name: string;
  variant_name: string;
  current_quantity: number;
  threshold: number;
  alert_type: 'low_stock' | 'out_of_stock';
  severity: 'warning' | 'critical';
}

export class InventoryService {
  constructor(private supabase: SupabaseClient<Database>) {}

  /**
   * Get current inventory levels with filtering and sorting
   */
  async getInventoryLevels(filters: {
    product_id?: string;
    category_id?: string;
    low_stock_only?: boolean;
    track_inventory_only?: boolean;
    search?: string;
    limit?: number;
    offset?: number;
  } = {}) {
    try {
      const {
        product_id,
        category_id,
        low_stock_only = false,
        track_inventory_only = true,
        search,
        limit = 50,
        offset = 0
      } = filters;

      let query = this.supabase
        .from('product_variants')
        .select(`
          id, name, sku, unit_amount, currency,
          inventory_quantity, low_stock_threshold, track_inventory,
          active, created_at, updated_at,
          products!inner(
            id, name, slug, category_id, active,
            product_categories(id, name)
          )
        `);

      // Apply filters
      if (track_inventory_only) {
        query = query.eq('track_inventory', true);
      }

      if (product_id) {
        query = query.eq('product_id', product_id);
      }

      if (category_id) {
        query = query.eq('products.category_id', category_id);
      }

      if (low_stock_only) {
        query = query.filter('inventory_quantity', 'lte', 'low_stock_threshold');
      }

      if (search) {
        query = query.or(
          `name.ilike.%${search}%,sku.ilike.%${search}%,products.name.ilike.%${search}%`
        );
      }

      // Apply pagination and sorting
      const { data: variants, error } = await query
        .eq('active', true)
        .eq('products.active', true)
        .order('inventory_quantity', { ascending: true })
        .order('products.name', { ascending: true })
        .range(offset, offset + limit - 1);

      if (error) {
        throw new DatabaseError('Failed to fetch inventory levels', { supabaseError: error });
      }

      // Enhance with calculated fields
      const enhancedVariants = (variants || []).map(variant => {
        const stockStatus = this.calculateStockStatus(
          variant.inventory_quantity,
          variant.low_stock_threshold
        );

        return {
          ...variant,
          stock_status: stockStatus.status,
          stock_severity: stockStatus.severity,
          days_of_stock: this.estimateDaysOfStock(variant.id, variant.inventory_quantity),
          stock_value: variant.inventory_quantity * variant.unit_amount
        };
      });

      return enhancedVariants;

    } catch (error) {
      console.error('Error fetching inventory levels:', error);
      if (error instanceof DatabaseError) {
        throw error;
      }
      throw new DatabaseError('Unexpected error fetching inventory levels');
    }
  }

  /**
   * Get inventory alerts (low stock, out of stock)
   */
  async getInventoryAlerts(): Promise<InventoryAlert[]> {
    try {
      const { data: variants, error } = await this.supabase
        .from('product_variants')
        .select(`
          id, name, sku, inventory_quantity, low_stock_threshold,
          products!inner(id, name, active)
        `)
        .eq('track_inventory', true)
        .eq('active', true)
        .eq('products.active', true)
        .lte('inventory_quantity', 'low_stock_threshold');

      if (error) {
        throw new DatabaseError('Failed to fetch inventory alerts', { supabaseError: error });
      }

      const alerts: InventoryAlert[] = (variants || []).map(variant => {
        const isOutOfStock = variant.inventory_quantity <= 0;
        
        return {
          id: variant.id,
          variant_id: variant.id,
          product_name: variant.products.name,
          variant_name: variant.name || 'Standard',
          current_quantity: variant.inventory_quantity,
          threshold: variant.low_stock_threshold,
          alert_type: isOutOfStock ? 'out_of_stock' : 'low_stock',
          severity: isOutOfStock ? 'critical' : 'warning'
        };
      });

      return alerts.sort((a, b) => {
        // Sort by severity (critical first), then by quantity
        if (a.severity !== b.severity) {
          return a.severity === 'critical' ? -1 : 1;
        }
        return a.current_quantity - b.current_quantity;
      });

    } catch (error) {
      console.error('Error fetching inventory alerts:', error);
      if (error instanceof DatabaseError) {
        throw error;
      }
      throw new DatabaseError('Unexpected error fetching inventory alerts');
    }
  }

  /**
   * Adjust inventory quantity (manual adjustment)
   */
  async adjustInventory(
    request: StockAdjustmentRequest, 
    userId: string
  ) {
    try {
      // Validate variant exists and tracks inventory
      const { data: variant, error: variantError } = await this.supabase
        .from('product_variants')
        .select('id, name, inventory_quantity, track_inventory, products!inner(name)')
        .eq('id', request.variant_id)
        .single();

      if (variantError || !variant) {
        throw new ResourceNotFoundError('Product variant', request.variant_id);
      }

      if (!variant.track_inventory) {
        throw new BusinessRuleError('Variant does not track inventory');
      }

      // Use the database function for atomic inventory update
      const { error: updateError } = await this.supabase
        .rpc('update_inventory', {
          p_variant_id: request.variant_id,
          p_quantity_change: request.quantity_change,
          p_movement_type: 'adjustment',
          p_reason: request.reason,
          p_reference_type: 'manual_adjustment',
          p_reference_id: null,
          p_user_id: userId
        });

      if (updateError) {
        throw new DatabaseError('Failed to adjust inventory', { supabaseError: updateError });
      }

      // Get updated variant data
      const { data: updatedVariant } = await this.supabase
        .from('product_variants')
        .select('inventory_quantity')
        .eq('id', request.variant_id)
        .single();

      return {
        success: true,
        variant_id: request.variant_id,
        previous_quantity: variant.inventory_quantity,
        new_quantity: updatedVariant?.inventory_quantity || 0,
        change: request.quantity_change
      };

    } catch (error) {
      console.error('Error adjusting inventory:', error);
      if (error instanceof ResourceNotFoundError || error instanceof BusinessRuleError || 
          error instanceof DatabaseError) {
        throw error;
      }
      throw new DatabaseError('Unexpected error adjusting inventory');
    }
  }

  /**
   * Bulk update inventory levels
   */
  async bulkUpdateInventory(
    updates: BulkStockUpdate[], 
    userId: string
  ) {
    try {
      const results = [];
      const errors = [];

      for (const update of updates) {
        try {
          // Get current quantity to calculate change
          const { data: variant } = await this.supabase
            .from('product_variants')
            .select('inventory_quantity, track_inventory')
            .eq('id', update.variant_id)
            .single();

          if (!variant || !variant.track_inventory) {
            errors.push({
              variant_id: update.variant_id,
              error: 'Variant not found or does not track inventory'
            });
            continue;
          }

          const quantityChange = update.new_quantity - variant.inventory_quantity;

          await this.supabase.rpc('update_inventory', {
            p_variant_id: update.variant_id,
            p_quantity_change: quantityChange,
            p_movement_type: 'adjustment',
            p_reason: update.reason,
            p_reference_type: 'bulk_update',
            p_reference_id: null,
            p_user_id: userId
          });

          results.push({
            variant_id: update.variant_id,
            success: true,
            previous_quantity: variant.inventory_quantity,
            new_quantity: update.new_quantity,
            change: quantityChange
          });

        } catch (error) {
          errors.push({
            variant_id: update.variant_id,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      return {
        success: errors.length === 0,
        results,
        errors,
        total_processed: updates.length,
        successful: results.length,
        failed: errors.length
      };

    } catch (error) {
      console.error('Error in bulk inventory update:', error);
      throw new DatabaseError('Unexpected error in bulk inventory update');
    }
  }

  /**
   * Restock inventory (add new stock)
   */
  async restockInventory(
    request: RestockRequest, 
    userId: string
  ) {
    try {
      // Validate variant
      const { data: variant, error } = await this.supabase
        .from('product_variants')
        .select('id, name, track_inventory, products!inner(name)')
        .eq('id', request.variant_id)
        .single();

      if (error || !variant) {
        throw new ResourceNotFoundError('Product variant', request.variant_id);
      }

      if (!variant.track_inventory) {
        throw new BusinessRuleError('Variant does not track inventory');
      }

      // Create restock reason with additional details
      let reason = `Restock: +${request.quantity} units`;
      if (request.supplier) {
        reason += ` from ${request.supplier}`;
      }
      if (request.notes) {
        reason += ` - ${request.notes}`;
      }

      // Update inventory
      const { error: updateError } = await this.supabase
        .rpc('update_inventory', {
          p_variant_id: request.variant_id,
          p_quantity_change: request.quantity,
          p_movement_type: 'in',
          p_reason: reason,
          p_reference_type: 'restock',
          p_reference_id: null,
          p_user_id: userId
        });

      if (updateError) {
        throw new DatabaseError('Failed to restock inventory', { supabaseError: updateError });
      }

      // Optionally track restock costs (you could add a restock_costs table)
      if (request.cost_per_unit) {
        const totalCost = request.cost_per_unit * request.quantity;
        // This could be logged to a costs tracking table
        console.log(`Restock cost: ${request.quantity} units at $${request.cost_per_unit} each = $${totalCost}`);
      }

      return {
        success: true,
        variant_id: request.variant_id,
        quantity_added: request.quantity,
        supplier: request.supplier,
        total_cost: request.cost_per_unit ? request.cost_per_unit * request.quantity : null
      };

    } catch (error) {
      console.error('Error restocking inventory:', error);
      if (error instanceof ResourceNotFoundError || error instanceof BusinessRuleError || 
          error instanceof DatabaseError) {
        throw error;
      }
      throw new DatabaseError('Unexpected error restocking inventory');
    }
  }

  /**
   * Get inventory movement history
   */
  async getInventoryMovements(
    variantId?: string,
    filters: {
      movement_type?: string;
      reference_type?: string;
      start_date?: string;
      end_date?: string;
      limit?: number;
      offset?: number;
    } = {}
  ) {
    try {
      const { 
        movement_type, 
        reference_type, 
        start_date, 
        end_date, 
        limit = 50, 
        offset = 0 
      } = filters;

      let query = this.supabase
        .from('inventory_movements')
        .select(`
          *,
          product_variants!inner(
            id, name, sku,
            products!inner(id, name)
          ),
          created_by_profile:profiles!created_by(
            id, username, display_name
          )
        `);

      // Apply filters
      if (variantId) {
        query = query.eq('variant_id', variantId);
      }

      if (movement_type) {
        query = query.eq('movement_type', movement_type);
      }

      if (reference_type) {
        query = query.eq('reference_type', reference_type);
      }

      if (start_date) {
        query = query.gte('created_at', start_date);
      }

      if (end_date) {
        query = query.lte('created_at', end_date);
      }

      const { data: movements, error } = await query
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        throw new DatabaseError('Failed to fetch inventory movements', { supabaseError: error });
      }

      return movements || [];

    } catch (error) {
      console.error('Error fetching inventory movements:', error);
      if (error instanceof DatabaseError) {
        throw error;
      }
      throw new DatabaseError('Unexpected error fetching inventory movements');
    }
  }

  /**
   * Get inventory analytics
   */
  async getInventoryAnalytics(startDate?: string, endDate?: string) {
    try {
      const start = startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
      const end = endDate || new Date().toISOString();

      // Get movement analytics
      const { data: movements, error: movementsError } = await this.supabase
        .from('inventory_movements')
        .select('movement_type, quantity, created_at, product_variants!inner(unit_amount)')
        .gte('created_at', start)
        .lte('created_at', end);

      if (movementsError) {
        throw new DatabaseError('Failed to fetch movement analytics');
      }

      // Get current stock levels
      const { data: stockLevels, error: stockError } = await this.supabase
        .from('product_variants')
        .select(`
          inventory_quantity, low_stock_threshold, track_inventory, unit_amount,
          products!inner(active)
        `)
        .eq('track_inventory', true)
        .eq('active', true)
        .eq('products.active', true);

      if (stockError) {
        throw new DatabaseError('Failed to fetch stock levels');
      }

      // Calculate analytics
      const movementData = movements || [];
      const stockData = stockLevels || [];

      // Movement analytics
      const totalMovements = movementData.length;
      const stockIn = movementData.filter(m => m.movement_type === 'in');
      const stockOut = movementData.filter(m => m.movement_type === 'out');
      const adjustments = movementData.filter(m => m.movement_type === 'adjustment');

      const totalStockIn = stockIn.reduce((sum, m) => sum + m.quantity, 0);
      const totalStockOut = stockOut.reduce((sum, m) => sum + Math.abs(m.quantity), 0);

      // Calculate stock value
      const totalStockValue = stockData.reduce(
        (sum, item) => sum + (item.inventory_quantity * item.unit_amount), 
        0
      );

      // Stock status analysis
      const totalVariants = stockData.length;
      const lowStockItems = stockData.filter(
        item => item.inventory_quantity <= item.low_stock_threshold
      ).length;
      const outOfStockItems = stockData.filter(
        item => item.inventory_quantity <= 0
      ).length;
      const healthyStockItems = totalVariants - lowStockItems;

      // Top moving items (by quantity moved)
      const variantMovements: Record<string, { quantity: number; value: number; variant_id: string }> = {};
      
      for (const movement of movementData.filter(m => m.movement_type === 'out')) {
        const variantId = movement.product_variants?.id || 'unknown';
        const unitAmount = movement.product_variants?.unit_amount || 0;
        const quantity = Math.abs(movement.quantity);
        
        if (!variantMovements[variantId]) {
          variantMovements[variantId] = { quantity: 0, value: 0, variant_id: variantId };
        }
        
        variantMovements[variantId].quantity += quantity;
        variantMovements[variantId].value += quantity * unitAmount;
      }

      const topMovingItems = Object.values(variantMovements)
        .sort((a, b) => b.quantity - a.quantity)
        .slice(0, 10);

      // Calculate turnover rate (simplified)
      const averageInventory = stockData.reduce(
        (sum, item) => sum + item.inventory_quantity, 
        0
      ) / totalVariants || 1;
      const turnoverRate = totalStockOut / averageInventory;

      return {
        summary: {
          total_variants: totalVariants,
          total_stock_value: Math.round(totalStockValue),
          healthy_stock_items: healthyStockItems,
          low_stock_items: lowStockItems,
          out_of_stock_items: outOfStockItems,
          stock_health_percentage: Math.round((healthyStockItems / totalVariants) * 100)
        },
        movements: {
          total_movements: totalMovements,
          stock_in: totalStockIn,
          stock_out: totalStockOut,
          net_movement: totalStockIn - totalStockOut,
          adjustments: adjustments.length,
          turnover_rate: Math.round(turnoverRate * 100) / 100
        },
        top_moving_items: topMovingItems,
        date_range: { start, end }
      };

    } catch (error) {
      console.error('Error fetching inventory analytics:', error);
      if (error instanceof DatabaseError) {
        throw error;
      }
      throw new DatabaseError('Unexpected error fetching inventory analytics');
    }
  }

  /**
   * Set low stock thresholds for variants
   */
  async setLowStockThresholds(
    updates: { variant_id: string; threshold: number }[]
  ) {
    try {
      const results = [];
      const errors = [];

      for (const update of updates) {
        try {
          const { error } = await this.supabase
            .from('product_variants')
            .update({ 
              low_stock_threshold: update.threshold,
              updated_at: new Date().toISOString()
            })
            .eq('id', update.variant_id);

          if (error) {
            errors.push({
              variant_id: update.variant_id,
              error: error.message
            });
          } else {
            results.push({
              variant_id: update.variant_id,
              threshold: update.threshold,
              success: true
            });
          }
        } catch (error) {
          errors.push({
            variant_id: update.variant_id,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      return {
        success: errors.length === 0,
        results,
        errors,
        total_processed: updates.length
      };

    } catch (error) {
      console.error('Error setting low stock thresholds:', error);
      throw new DatabaseError('Unexpected error setting low stock thresholds');
    }
  }

  /**
   * Generate inventory report
   */
  async generateInventoryReport(format: 'summary' | 'detailed' = 'summary') {
    try {
      const [alerts, analytics, levels] = await Promise.all([
        this.getInventoryAlerts(),
        this.getInventoryAnalytics(),
        this.getInventoryLevels({ limit: 1000 })
      ]);

      const report = {
        generated_at: new Date().toISOString(),
        format,
        summary: analytics.summary,
        alerts: {
          total: alerts.length,
          critical: alerts.filter(a => a.severity === 'critical').length,
          warnings: alerts.filter(a => a.severity === 'warning').length,
          items: format === 'detailed' ? alerts : alerts.slice(0, 10)
        },
        stock_movements: analytics.movements,
        recommendations: this.generateInventoryRecommendations(alerts, analytics, levels)
      };

      if (format === 'detailed') {
        report['detailed_levels'] = levels;
      }

      return report;

    } catch (error) {
      console.error('Error generating inventory report:', error);
      throw new DatabaseError('Failed to generate inventory report');
    }
  }

  /**
   * Calculate stock status
   */
  private calculateStockStatus(currentQuantity: number, threshold: number) {
    if (currentQuantity <= 0) {
      return { status: 'out_of_stock', severity: 'critical' as const };
    } else if (currentQuantity <= threshold) {
      return { status: 'low_stock', severity: 'warning' as const };
    } else {
      return { status: 'in_stock', severity: 'normal' as const };
    }
  }

  /**
   * Estimate days of stock remaining (simplified calculation)
   */
  private estimateDaysOfStock(variantId: string, currentQuantity: number): number {
    // This is a simplified version - in reality you'd calculate based on historical sales data
    // For now, assume average sale of 1 unit per 7 days if no data available
    const averageDailySales = 1 / 7;
    return currentQuantity > 0 ? Math.round(currentQuantity / averageDailySales) : 0;
  }

  /**
   * Generate inventory recommendations
   */
  private generateInventoryRecommendations(
    alerts: InventoryAlert[],
    analytics: any,
    levels: any[]
  ): string[] {
    const recommendations = [];

    // Critical stock issues
    const criticalItems = alerts.filter(a => a.severity === 'critical');
    if (criticalItems.length > 0) {
      recommendations.push(
        `🚨 ${criticalItems.length} items are out of stock and need immediate restocking`
      );
    }

    // Low stock warnings
    const warningItems = alerts.filter(a => a.severity === 'warning');
    if (warningItems.length > 5) {
      recommendations.push(
        `⚠️ ${warningItems.length} items are running low on stock`
      );
    }

    // Stock health
    if (analytics.summary.stock_health_percentage < 70) {
      recommendations.push(
        `📊 Overall stock health is ${analytics.summary.stock_health_percentage}% - consider reviewing thresholds`
      );
    }

    // High turnover items
    if (analytics.top_moving_items?.length > 0) {
      const topItem = analytics.top_moving_items[0];
      recommendations.push(
        `🔄 Monitor high-turnover items closely for potential stockouts`
      );
    }

    // Excess inventory (items with very high stock levels)
    const excessItems = levels.filter(l => 
      l.inventory_quantity > (l.low_stock_threshold * 10)
    ).length;
    
    if (excessItems > 0) {
      recommendations.push(
        `📦 ${excessItems} items may have excess inventory - consider adjusting order quantities`
      );
    }

    return recommendations;
  }
}
